---
author: '[Matt Lowes](mailto:email@oneacrefund.org)'
date: '`r format(Sys.time(), "%B %d, %Y")`'
output:
  html_notebook:
    number_sections: yes
    code_folding: hide
    theme: flatly
    toc: yes
    toc_depth: 6
    toc_float: yes
    css: static/styles.css
---
<title>Title</title>
```{r setup, include=FALSE}
#### set up
## clear environment and console
rm(list = ls())
cat("\014")

## set up some global options
# always set stringsAsFactors = F when loading data
options(stringsAsFactors=FALSE)

# show the code
knitr::opts_chunk$set(echo = TRUE)

# define all knitr tables to be html format
options(knitr.table.format = 'html')

# change code chunk default to not show warnings or messages
knitr::opts_chunk$set(warning = FALSE, message = FALSE)

## load libraries
# dplyr and tibble are for working with tables
# reshape is for easy table transformation
# knitr is to make pretty tables at the end
# ggplot2 is for making graphs
# readxl is for reading in Excel files
# MASS is for running boxcox tests
# gridExtra is for arranging plots
# cowplot is for adding subtitles to plots
# robustbase is to run robust regressions to compensate for outliers
# car is for performing logit transformations
libs <- c("tidyverse", "knitr", "readxl", "curl", "raster", "rgdal")
lapply(libs, require, character.only = T, quietly = T, warn.conflicts = F)

#### define helpful functions
# define function to adjust table widths
html_table_width <- function(kable_output, width) {
  width_html <- paste0(paste0('<col width="', width, '">'), collapse = "\n")
  sub("<table>", paste0("<table>\n", width_html), kable_output)
}
options(readr.show_progress = FALSE)
select <- dplyr::select
```

# Objectives

We're trying to make soil classes for 1AF Kenya to inform the placement of on-farm nutrient omission trials. This analysis accesses data from the [AfSIS soil grids project](http://data.isric.org/geonetwork/srv/eng/catalog.search#/home), combines them into a feature set and identifies clusters across sampling units to inform trial placement. 

# Data

Most of the data have been zipped. I'm just goint to manually unzip it to simplify the process. Here's the complete list of the data I've tried to access from the online repository:

* Africa SoilGrids pH (predictions for pH H2O (10) for individual depth intervals (0-5, 5-15, 15-30 cm); make weighted average 
    + **af_PHIHOX_T__M_sd1_250m.tif**
* Africa SoilGrids organic C (predictions for SOC (g/kg) for individual depth intervals (0-5, 5-15, 15-30 cm); make weighted average 
    + **af_ORCDRC_T__M_sd1_250m.tif**
* Africa SoilGrids total N 2017 (predictions for TN (mg/kg) for 0-30 cm   
    + **af250m_nutrient_n_m_agg30cm.tif**
* Africa SoilGrids texture (textural classes derived from predictions for sand, silt & clay for individual depth intervals (0-5, 5-15, 15-30 cm); make weighted average 
    + **af_TEXMHT_T__M_sd1_250m.tif**
* Africa SoilGrids root zone texture (textural classes derived from predictions for sand, silt & clay for 0-30 cm (also available for the rootable depth) with a resolution of 1km 
    + **af_agg_30cm_TEXCLSS__M_1km.tif**
* Africa SoilGrids sand (predictions for sand content (w%) for individual depth intervals (0-5, 5-15, 15-30 cm); make weighted average 
    + **af_SNDPPT_T__M_sd1_250m.tif**
* Africa SoilGrids silt (predictions for silt content (w%) for individual depth intervals (0-5, 5-15, 15-30 cm); make weighted average 
    + **af_SLTPPT_T__M_sd1_250m.tif**
* Africa SoilGrids clay (predictions for clay content (w%) for individual depth intervals (0-5, 5-15, 15-30 cm); make weighted average 
    + **af_CLYPPT_T__M_sd1_250m.tif**
* Africa SoilGrids CEC (predictions for CEC (cmolc/kg) for individual depth intervals (0-5, 5-15, 15-30 cm); make weighted average 
    + **af_CEC_T__M_sd1_250m.tif**
* Africa SoilGrids P (predictions for available P, according to Mehlich 3 (mg/100kg; thus divide by 100 for ppm) for 0-30 cm 
* Africa SoilGrids P (predictions for total P (mg/kg) for 0-30 cm         
    + **af250m_nutrient_p_t_m_agg30cm.tif**
* Africa SoilGrids root zone coarse (predictions for coarse fragments content (v%) for 0-30 cm (also for rootable depth) at 1km resolution 
    + **af_agg_30cm_CRFVOL__M_1km.tif**
* Africa SoilGrids root zone (derived maps for rootable depth (cm), and other properties aggregated over 0-30 cm as well as over root zone depth, at 1 km resolution 
    + **af_ERZD__M_1km.tif**

And Johan clarified that the weights refer to amount of soil depth:
the weights refer to the depth intervals :

* 0-5 = 5/30 - this refers to `sd1` in the file names
* 5-15 = 10/30 - this refers to `sd2` in the file names
* 15-30 = 15/30 - this refers to `sd3` in the file names

```{r}
firstWeight <- 5/30
secondWeight <- 10/30
thirdWeight <- 15/30

weightList <- list(firstWeight, secondWeight, thirdWeight)
```


```{r}
rawDir <- normalizePath(file.path("..", "soil_grids_raw_data"))

datDir <- normalizePath(file.path("..", "soil_grids_data"))

tifFiles <- paste0(rawDir, "/", list.files(dataDir, pattern = ".tif$"))

```

I want to import all of these rasters but it's important that they be clearly grouped so that I can create weighted layers for all N, C, P, etc. before combining them into a single data frame. The following functions will import the selected rasters then perform the necessary calculations to prepare that soil nutrient feature for the end analysis.

The overall soil rasters are too big to do the calculations first (even if I'm doing them as efficiently as possible which I may not be). Therefore I first need to trim the larger raster down to just Kenya before calculating the weights and averages.

## Kenya boundaries

```{r}
if(!file.exists(paste0(outputDir, "/GADM_2.8_KEN_adm2.rds"))){
  keBoundaries <- getData("GADM", country='KE', level=2, path = dataDir) 
} else {
  keBoundaries <- readRDS(paste0(outputDir, "/GADM_2.8_KEN_adm2.rds"))
}

## transform the shape file to the correct CRS system
keBoundaries <- spTransform(keBoundaries, CRS("+proj=laea +lat_0=5 +lon_0=20 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0"))


# I additionally want to subset this down to just western Kenya because it's too computationally intentsive to run these calculations for other areas. I'm going to subset the shape file to just western Kenya and the plot it to confirm I've done it correctly.

# from Name 1
westernAreas <- c("Bungoma", "Busia", "Elgeyo-Marakwet", "Homa Bay", "Kakamega", "Kericho", "Kisii", "Kisumu", "Migori", "Nyamira", "Siaya", "Vihiga")

westernMap <- keBoundaries[match(tolower(westernAreas), tolower(keBoundaries$NAME_1)),]

plot(westernMap)
```

```{r eval=FALSE, include=FALSE}
plot(keBoundaries)
```


## Applying weights

It's not going to be very elegant but I'm going to manually apply the weights to the soil layers because I can't figure out a more efficient way to do this. Ultimately I probably want that in a separate data preparation script but for the time being I'll just have it save a final file that I won't refresh unless I need to. Here's a [helpful reference](https://gis.stackexchange.com/questions/61243/clipping-a-raster-in-r).

```{r}
tifFinder <- function(input){
  # finds the right layers from the full set of input data, tifFiles
  #outputs list of those files.
  tifFiles[grep(input, tifFiles)]
}


importRasterAsList <- function(listInput){
  # import the relevant files for the soil layer
  # outputs a raster list
  rasterFile = lapply(listInput, function(x) raster(x))
}

addWeights <- function(rasterList, weightList){
  
  # confirm that this approach gives the same result as doing it manually.
  # confirmed that this is leading to same result!
  
  # make sure it's in order!
    r = Map("*", rasterList, weightList)
    return(r)
  
}


```

```{r}
forceUpdate <- FALSE

if(forceUpdate){
  
  # I can't hold all the raw data in memory so I'll run these one at a time and then only keep the analyzed results on the hd.

# ph but with functions
if(!file.exists(paste(datDir, "output", "pH_weighted_layer.tif", sep = "/")) | forceUpdate){
  print("tried")
  pHLayer <- mean(stack(addWeights(importRasterAsList(tifFinder("af_PHIHOX_T__M")), weightList)))
  
  writeRaster(pHLayer, file = paste(outputDir, "output", "pH_weighted_layer.tif", sep = "/"), format="GTiff", overwrite=TRUE)
} else {
  pHLayer <- raster(paste(datDir, "output", "pH_weighted_layer.tif", sep = "/"))
}

# carbon
if(!file.exists(paste(datDir, "output", "carbon_weighted_layer.tif", sep = "/")) | forceUpdate){
  carbonLayer <- mean(stack(addWeights(importRasterAsList(tifFinder("af_ORCDRC_T__M")), weightList)))
  
  writeRaster(carbonLayer, file = paste(dataDir, "output", "carbon_weighted_layer.tif", sep = "/"), format="GTiff", overwrite=TRUE)
} else {
  carbonLayer <- raster(paste(dataDir, "output", "carbon_weighted_layer.tif", sep = "/"))
}

# texture
if(!file.exists(paste(dataDir, "output", "texture_weighted_layer.tif", sep = "/")) | forceUpdate){
  textureLayer <- mean(stack(addWeights(importRasterAsList(tifFinder("af_TEXMHT_T__M")), weightList)))
  
  writeRaster(textureLayer, file = paste(dataDir, "output", "texture_weighted_layer.tif", sep = "/"), format="GTiff", overwrite=TRUE)
} else {
  textureLayer <- raster(paste(dataDir, "output", "texture_weighted_layer.tif", sep = "/"))
}

# sand content
if(!file.exists(paste(dataDir, "output", "sand_weighted_layer.tif", sep = "/")) | forceUpdate){
  sandLayer <- mean(stack(addWeights(importRasterAsList(tifFinder("af_SNDPPT_T__M")), weightList)))
  
  writeRaster(sandLayer, file = paste(dataDir, "output", "sand_weighted_layer.tif", sep = "/"), format="GTiff", overwrite=TRUE)
} else {
  
}
# silt content
if(!file.exists(paste(dataDir, "output", "silt_weighted_layer.tif", sep = "/")) | forceUpdate){
  siltLayer <- mean(stack(addWeights(importRasterAsList(tifFinder("af_SLTPPT_T__M")), weightList)))
  
  writeRaster(siltLayer, file = paste(dataDir, "output", "silt_weighted_layer.tif", sep = "/"), format="GTiff", overwrite=TRUE)
} else {
  siltLayer <- raster(paste(dataDir, "output", "silt_weighted_layer.tif", sep = "/"))
}

# clay content
if(!file.exists(paste(dataDir, "output", "clay_weighted_layer.tif", sep = "/")) | forceUpdate){
  clayLayer <- mean(stack(addWeights(importRasterAsList(tifFinder("af_CLYPPT_T__M")), weightList)))
  
  writeRaster(clayLayer, file = paste(dataDir, "output", "clay_weighted_layer.tif", sep = "/"), format="GTiff", overwrite=TRUE)
} else {
  clayLayer <- raster(paste(dataDir, "output", "clay_weighted_layer.tif", sep = "/"))
}

# CEC
if(!file.exists(paste(dataDir, "output", "cec_weighted_layer.tif", sep = "/")) | forceUpdate){
  cecLayer <- mean(stack(addWeights(importRasterAsList(tifFinder("af_CEC_T__M")), weightList)))
  
  writeRaster(cecLayer, file = paste(dataDir, "output", "cec_weighted_layer.tif", sep = "/"), format="GTiff", overwrite=TRUE)
} else {
  cecLayer <- raster(paste(dataDir, "output", "cec_weighted_layer.tif", sep = "/"))
  }
}
```

## Importing other layers

This summary repeats content from above:

* Africa SoilGrids root zone texture (textural classes derived from predictions for sand, silt & clay for 0-30 cm (also available for the rootable depth) with a resolution of 1km 
    + **af_agg_30cm_TEXCLSS__M_1km.tif**
* Africa SoilGrids P (predictions for available P, according to Mehlich 3 (mg/100kg; thus divide by 100 for ppm) for 0-30 cm 
* Africa SoilGrids P (predictions for total P (mg/kg) for 0-30 cm         
    + **af250m_nutrient_p_t_m_agg30cm.tif**
* Africa SoilGrids root zone coarse (predictions for coarse fragments content (v%) for 0-30 cm (also for rootable depth) at 1km resolution 
    + **af_agg_30cm_CRFVOL__M_1km.tif**
* Africa SoilGrids root zone (derived maps for rootable depth (cm), and other properties aggregated over 0-30 cm as well as over root zone depth, at 1 km resolution 
    + **af_ERZD__M_1km.tif**
    
    
I'm importing these directly because it's not computationally intensive to do so.

```{r}
zoneTextureLayer <- importRasterAsList(tifFinder("af_agg_30cm_TEXCLSS__M_1km.tif"))[[1]]

phosLayer <- importRasterAsList(tifFinder("af250m_nutrient_p_t_m_agg30cm.tif"))[[1]]

zoneCoarseLayer <- importRasterAsList(tifFinder("af_agg_30cm_CRFVOL__M_1km.tif"))[[1]]

zoneLayer <- importRasterAsList(tifFinder("af_ERZD__M_1km.tif"))[[1]]
```

# Stacking data

```{r}
soilStack <- stack(pHLayer, carbonLayer, textureLayer, sandLayer, clayLayer, cecLayer, zoneTextureLayer, phosLayer, zoneCoarseLayer, zoneLayer)
```


## Cropping data

`Crop` extent of the raster and then `mask` raster to fit the outlines of Kenya.

```{r}
soilDat <- crop(soilStack, extent(keBoundaries))

soilDat <- mask(soilDat, keBoundaries)
```

# Clustering Code

# Clustering analysis

# Output

# Appendix
